<!-- üî• Full code with fireworks below -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mega Puzzle Game üß©</title>
  <style>
    /* ... All your existing CSS remains unchanged ... */
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to right, #fbc2eb, #a6c1ee);
      margin: 0;
      padding: 20px;
      overflow-x: hidden;
    }
    /* (Rest of your styles stay the same...) */
  </style>
</head>
<body>
  <header>
    <h1>üß† Mega Puzzle Game (8x8)</h1>
    <div id="preview"></div>
  </header>

  <div id="timer">‚è±Ô∏è Time: 0s</div>
  <div id="puzzle-container"></div>

  <div id="controls">
    <button onclick="createPuzzle()">üîÅ Restart Puzzle</button>
    <button onclick="checkErrors()">üîç Find Error</button>
  </div>

  <div id="message"></div>
  <div id="celebration" class="celebration" style="display: none;">üéÜüíñüéá</div>
  <canvas id="fireworkCanvas"></canvas>

  <script>
    const puzzle = document.getElementById("puzzle-container");
    const message = document.getElementById("message");
    const preview = document.getElementById("preview");
    const timerEl = document.getElementById("timer");
    const celebration = document.getElementById("celebration");

    const imageSrc = "mots.png";
    preview.style.backgroundImage = `url(${imageSrc})`;

    let tiles = [];
    const gridSize = 8;
    const containerSize = 600;
    const tileSize = containerSize / gridSize;

    let timer = 0;
    let interval;

    function createPuzzle() {
      puzzle.innerHTML = "";
      message.textContent = "";
      tiles = [];
      clearInterval(interval);
      timer = 0;
      timerEl.textContent = "‚è±Ô∏è Time: 0s";
      celebration.style.display = "none";
      preview.style.display = "block";

      for (let i = 0; i < gridSize * gridSize; i++) {
        const tile = document.createElement("div");
        tile.classList.add("tile");
        tile.setAttribute("data-correct", i);
        tiles.push(tile);
      }

      shuffleArray(tiles);

      tiles.forEach((tile, index) => {
        tile.setAttribute("data-current", index);

        const pos = tile.getAttribute("data-correct");
        const x = (pos % gridSize) * -tileSize;
        const y = Math.floor(pos / gridSize) * -tileSize;
        tile.style.width = tile.style.height = `${tileSize}px`;
        tile.style.backgroundImage = `url(${imageSrc})`;
        tile.style.backgroundSize = `${containerSize}px ${containerSize}px`;
        tile.style.backgroundPosition = `${x}px ${y}px`;

        puzzle.appendChild(tile);
      });

      enableDragAndDrop();
      updateCorrectCount();
      startTimer();
    }

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function enableDragAndDrop() {
      let dragged;

      document.querySelectorAll(".tile").forEach(tile => {
        tile.draggable = true;

        tile.addEventListener("dragstart", e => {
          dragged = e.target;
        });

        tile.addEventListener("dragover", e => e.preventDefault());

        tile.addEventListener("drop", e => {
          e.preventDefault();
          if (dragged !== e.target) {
            swapTiles(dragged, e.target);
            updateCorrectCount();
            checkWin();
          }
        });
      });
    }

    function swapTiles(tile1, tile2) {
      const tempCurrent = tile1.getAttribute("data-current");
      tile1.setAttribute("data-current", tile2.getAttribute("data-current"));
      tile2.setAttribute("data-current", tempCurrent);

      const tempHTML = tile1.outerHTML;
      tile1.outerHTML = tile2.outerHTML;
      tile2.outerHTML = tempHTML;

      enableDragAndDrop();
    }

    function updateCorrectCount() {
      const currentTiles = document.querySelectorAll(".tile");
      let correctCount = 0;
      for (let i = 0; i < currentTiles.length; i++) {
        if (currentTiles[i].getAttribute("data-correct") == i) {
          correctCount++;
          currentTiles[i].style.border = "0.5px solid white";
        }
      }
      message.textContent = `‚úîÔ∏è ${correctCount} / 64 tiles correct`;
    }

    function checkWin() {
      const currentTiles = document.querySelectorAll(".tile");
      for (let i = 0; i < currentTiles.length; i++) {
        if (currentTiles[i].getAttribute("data-correct") != i) return;
      }

      clearInterval(interval);
      message.textContent = "üéâ Wow, very good!";
      puzzle.innerHTML = "";
      preview.style.display = "none";
      celebration.style.display = "flex";
      launchFireworks(7);
    }

    function startTimer() {
      interval = setInterval(() => {
        timer++;
        timerEl.textContent = `‚è±Ô∏è Time: ${timer}s`;
      }, 1000);
    }

    // üéÜ Firework Effect
    const canvas = document.getElementById("fireworkCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    let fireworks = [];

    function random(min, max) {
      return Math.random() * (max - min) + min;
    }

    class Firework {
      constructor() {
        this.reset();
      }
      reset() {
        this.x = random(canvas.width * 0.2, canvas.width * 0.8);
        this.y = canvas.height;
        this.targetY = random(canvas.height * 0.2, canvas.height * 0.5);
        this.speed = random(4, 7);
        this.exploded = false;
        this.particles = [];
      }
      update() {
        if (!this.exploded) {
          this.y -= this.speed;
          if (this.y <= this.targetY) {
            this.exploded = true;
            for (let i = 0; i < 50; i++) {
              this.particles.push(new Particle(this.x, this.y));
            }
          }
        } else {
          this.particles.forEach(p => p.update());
          this.particles = this.particles.filter(p => p.alpha > 0);
        }
      }
      draw() {
        if (!this.exploded) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = "white";
          ctx.fill();
        } else {
          this.particles.forEach(p => p.draw());
        }
      }
    }

    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = random(0, 2 * Math.PI);
        this.speed = random(1, 5);
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.alpha = 1;
        this.gravity = 0.05;
        this.color = `hsl(${Math.floor(random(0, 360))}, 100%, 60%)`;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.alpha -= 0.02;
      }
      draw() {
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    function animateFireworks() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      fireworks.forEach(f => {
        f.update();
        f.draw();
      });
      fireworks = fireworks.filter(f => f.particles.length > 0 || !f.exploded);
      requestAnimationFrame(animateFireworks);
    }

    function launchFireworks(count = 5) {
      for (let i = 0; i < count; i++) {
        fireworks.push(new Firework());
      }
      animateFireworks();
    }

    // üîç Error check feature with password
    function checkErrors() {
      const input = prompt("üîê Enter password to find errors:");
      if (input !== "baby") {
        alert("‚ùå Incorrect password!");
        return;
      }

      const currentTiles = document.querySelectorAll(".tile");
      currentTiles.forEach((tile, index) => {
        const correctIndex = parseInt(tile.getAttribute("data-correct"));
        if (correctIndex !== index) {
          tile.style.border = "3px solid red";
        } else {
          tile.style.border = "0.5px solid white";
        }
      });

      message.textContent += " üö® Errors highlighted!";
    }

    createPuzzle();
  </script>
</body>
</html>
